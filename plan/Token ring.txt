Этот уровень использует уровень Replica и реализует алгоритм сети с токеном.


Узел бывает в двух состояниях: Хранитель токена и Ожидающий. 
Ожидающие не проявляют никакой активности в посылке сообщений, только отвечают на запросы.
Хранители токена отвечают на все те же сообщения что и Ожидающие, и отправляют какие-то свои сообщения.



Когда узел становится Хранителем, он выполняет требуемые вычисления, и ищет следующий узел в сети.
Поиск осуществляется следующим образом: рассылается броадкаст, на который узлы отвечают своим MAC-адресом. Значения адресов упорядочиваются в порядке возрастания и выбирается следующий за нашим, либо самый первый если наш MAC больше остальных.
Если ничего не получили, то ???

Затем мы пытаемся передать данные узлу. Если на какой-то стадии связь обрывается, начинаем заново с выбора следующего узла.


Кроме того, Хранители каждые T секунд рассылают броадкаст что они живы. Соответственно если Ожидающий не слышит Хранителя T секунд, он инициирует протокол восставления токена.


Протокол восстановления токена:
???



Если в сети несколько Хранителей, то вероятно один услышит броадкаст от другого. Тогда услышавший инициирует протокол устранения лишнего токена.

Описание:
Состоянием "заморозка" назовём такое, в котором Хранитель не передаёт токен дальше (но может передавать данные следующему).
Пусть -A- услышал броадкаст от -B-. 
Тогда -A- впадает в заморозку на время выполнения протокола и отправляет сообщение -B- "подожди". Если на него ответят "я уже не хранитель", ничего не делаем. Если ответят "Ок, мой MAC=..., вычислено ..." (при этом -B- заморозится), то сравниваем пары (сколько вычислено, MAC) его со своими, и отправляем -B- результат. Соответственно тот у кого меньше, оставляет полномочия Хранителя.

Возможно, что в сети будет больше двух Хранителей. Поэтому Хранитель говорит "подожди" только первому Хранителю которого услышал.
При общении с другим Хранителем мы используем таймаут (k + (1 - k) * Math.random()) * T (k выбрано заранее) времени, если он истёк то завершаем протокол. По завершении шлём броадкаст что мы живы (раньше чем положено).
Это необходимо в ситуцаии, когда, например, Хранители A, B, C одновременно отправляют друг другу броадкаст, и A получает первый броадкаст от B, B от С, C от A. Тогда A откажет в общении с C, C откажет B и B Откажет A, общение не состоится. 
Если использовать постоянный таймаут, такая ситация может повторятся до бесконечности. Однако, в случае со случайным таймаутом, 2 Хранителя вышедших из заморозки раньше других смогут пообщатся без других.

