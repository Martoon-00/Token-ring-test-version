Каждый узел хранит карту подсети (циклический связный список всех узлов) 
и счётчик этих карт (вместе с картой будет отправляться id, чтобы при получении устаревшей карты от другого узла не затереть наши данные)
Помимо этого, в каждой подсети есть главный узел (не то что Хранитель токена из уровня Algorithm)
У узлов есть "уникальное значение", которое можно сравнивать. Таким образом, узлы задают упорядоченное множество, и для достижения консенсуса в выборе узла можно взять узел с наиобльшим уникальным значением


Этот уровень должен уметь общатся:
со всеми в подсети. Если с кем-то не удалось, то такой узел исключается из подсети.
со следующим узлом. Если с ним не удалось, он исключается и производится попытка поговорить с новым следующим узлом.
При этом если узлов больше нет, то мы ждём их появления (в обоих случаях).

Под "общением" мы понимаем возможность последовательных отправок-получений ответа с конкретным узлом.


Если отправка сообщения не удалась, то надо удалить вершину из сети.
Для этого сообщаем о необходимости удалить узел главному узлу. 
* В свою очередь главный узел, если этот узел у него в карте есть, удаляет его, увеличивает счётчик карт и рассылает всем новую карту сети. Если такого узла в карте нет, ничего делать не надо.
Если же мы пытаемся удалить главный узел (тогда, понятно, нет смысла с ним разговаривать), или не можем с ним связаться, то уходим в депрессию и образуем подсеть из самого себя.


Главный узел (назовём его A) переодически рассылает броадкаст с информацией о подсети. 
Если другой главный узел B, с рангом меньшим чем у A, получает такое сообщение,
то он оставляет пост главного, и отправляет A сообщение со всеми узлами своей подсети и счётчиком карт.
"А" делает свой счётчик равным максимуму старого счётчика и счётчика A, увеличивает новый счётчк, обновляет карту, и, как обычно, отправляет её всем в новой сети. 

Если так получится, что B оставит свои полномочия, но просьба об объединении до A не дойдёт, то
скоро все в подсети B поймут что главного нет и сами объединятся с A. Но вероятность этого невелика. (а может и велика, если чувак с самым большим MAC нестабильный)


Если узел остался один в подсети, то не позже следующей посылки сообщения он станет главным.
В этом состоянии он будет пытаться объединится с другими узлами. Пока это не произойдёт, отправка требуемого сообщения не будет завершена.


Ещё, если внутри подсети мы будет общаться броадкастами, то на этом уровне надо отсекать сообщения из других сетей (можно передавать адрес главного узла).

Так же, нужно с каждым сообщением отправлять хеш карты подсети. Принимающая сторона, если у её карты не такой хеш,
должна уведомить отправителя, после чего обе вершины обратятся к главному узлу чтобы выслал им свежую карту.
Таким образом, на любое отправляемое сообщение в пределах подсети можно получить в качестве ответа что, мол, фейл, тогда нужно получить у главного новую карту и повторить действие.
Если этого не сделать, отношение "A считает что B находится с ним в одной сети" не будет ни симметричным, ни транзитивным,
тогда этот уровень могли бы использовать только централизованные алгоритмы



Таким образом, этот уровень гарантирует достаку сообщений, но за неопределённое время. Например если в сети больше нет узлов, доставка займёт бесконечное количество времени.